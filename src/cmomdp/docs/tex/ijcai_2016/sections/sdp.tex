\section{Parameterized Symbolic Dynamic Programming}
\label{sec:sdp}

Symbolic Dynamic Programming (SDP)~\parencite{Boutilier_IJCAI_2001} is the process of performing dynamic programming
via symbolic manipulation. In the following sections we present a brief overview of SDP operations and also show
how SDP can be used to solve parameterized MDPs.

\subsection{Symbolic Case Calculus}

SDP assumes that all functions can be represented in case statement form \parencite{Boutilier_IJCAI_2001} as follows:
{\footnotesize 
    \abovedisplayskip=5pt
    \belowdisplayskip=0pt
    \begin{align*}
        f = 
        \begin{cases}
            \phi_1: & f_1 \\ 
            \vdots & \vdots\\ 
            \phi_k: & f_k \\ 
        \end{cases}
    \end{align*}
}%

Here, $ f_i $ are linear expressions over $ \vec{x} $ and $\phi_i$ are logical formulae defined over the state $( \vec{d}, \vec{x})$ that can consist of arbitrary logical combinations of boolean variables and linear inequalities $\left( \geq, >, <, \leq \right)$ over continuous variables. We assume that the set of conditions $\left\lbrace \phi_1, \ldots, \phi_k \right\rbrace$ disjointly and exhaustively partition $(\vec{d}, \vec{x})$ such that $f$ is well-defined for all $(\vec{d}, \vec{x})$. In this paper we restrict the $f_i$ to be either constant or linear functions of the state variable $\vec{x}$. Henceforth, we refer to functions with linear $\phi_i$ and piecewise constant $f_i$ as linear piecewise constant (LPWC) and functions with linear $\phi_i$ and piecewise linear $f_i$ as linear piecewise linear (LPWL) functions.

Operations on case statements may be either unary or binary. All of the operations presented here are closed form for LPWC and LPWL functions. We refer the reader to \parencite{Sanner_UAI_2011,Zamani_AAAI_2012} for more thorough expositions of SDP for piecewise continuous functions.

Unary operations on a single case statement \emph{f}, such as scalar multiplication $c \cdot f$ where $ c \in \mathbb{R} $, are applied to  each $f_i$ ($1 \leq i \leq k$). Binary operations such as addition, subtraction and multiplication are executed in two stages. Firstly, the cross-product of the logical partitions of each case statement is taken, producing paired partitions. Finally, the binary operation is applied to the resulting paired partitions. The ``cross-sum'' $\oplus$ operation can be performed on two cases in the following manner:
{\footnotesize 
%    \abovedisplayskip=5pt
%    \belowdisplayskip=0pt
    \begin{center}
        \begin{tabular}{r c c c l}
            $\begin{cases}
            \phi_1: \hspace{-1mm} & \hspace{-1mm} f_1  \\ 
            \phi_2: \hspace{-1mm} & \hspace{-1mm} f_2  \\ 
            \end{cases}$
            $\oplus$
            &
            \hspace{-4mm}
            $\begin{cases}
            \psi_1: \hspace{-1mm} & \hspace{-1mm} g_1  \\ 
            \psi_2: \hspace{-1mm} & \hspace{-1mm} g_2  \\ 
            \end{cases}$
            &
            \hspace{-4mm} 
            $ = $
            &
            \hspace{-4mm}
            $\begin{cases}
            \phi_1 \wedge \psi_1: & f_1 + g_1 \\
            \phi_1 \wedge \psi_2: & f_1 + g_2 \\
            \phi_2 \wedge \psi_1: & f_2 + g_1 \\
            \phi_2 \wedge \psi_2: & f_2 + g_2  \\
            \end{cases}$
        \end{tabular}
    \end{center}
}%
%\vspace{-4em}

\noindent ``cross-subtraction'' $\ominus$ and ``cross-multiplication'' $\otimes$ are defined in a similar manner but with the addition operator replaced by the subtraction and multiplication operators, respectively. Some partitions resulting from case operators may be inconsistent and are thus removed.

Substitution into case statements is performed via a set $\theta$ of variables and their substitutions e.g. $\theta = \left\{ x'_1/(x_1 + x_2) \right\}$, where the LHS of the / represents the substitution variable and the RHS of the / represents the expression that should be substituted in its place. $\theta$ can be applied to both non-case functions $f_i$ and case partitions $\phi_i$ as $f_i\theta$ and $\phi_i\theta$, respectively. Substitution into case statements can be written as:
{\footnotesize 
    \abovedisplayskip=5pt
    \belowdisplayskip=0pt
    \begin{align*}
        f\theta = 
        \begin{cases}
            \phi_1\theta: & f_1\theta \\ 
            \vdots & \vdots\\ 
            \phi_k\theta: & f_k\theta \\ 
        \end{cases}
    \end{align*}
}%

Substitution is used when calculating integrals with respect to deterministic $\delta$  transitions~\parencite{Sanner_UAI_2011}.

Maximisation over cases, known as $\casemax$, is defined as:
{\footnotesize 
    \abovedisplayskip=0pt
    \belowdisplayskip=0pt
    \begin{center}
        \begin{tabular}{r c c c l}
            \hspace{-7mm} 
            
            $\casemax \Bigg(
            \begin{cases}
            \phi_1: \hspace{-1mm} & \hspace{-1mm} f_1 \\ 
            \phi_2: \hspace{-1mm} & \hspace{-1mm} f_2 \\ 
            \end{cases}$
            $,$
            &
            \hspace{-4mm}
            $\begin{cases}
            \psi_1: \hspace{-1mm} & \hspace{-1mm} g_1 \\ 
            \psi_2: \hspace{-1mm} & \hspace{-1mm} g_2 \\ 
            \end{cases} \Bigg)$
            &
            \hspace{-4mm} 
            $ = $
            &
            \hspace{-4mm}
            $\begin{cases}
            \phi_1 \wedge \psi_1 \wedge f_1 > g_1    : & \hspace{-2mm} f_1 \\ 
            \phi_1 \wedge \psi_1 \wedge f_1 \leq g_1 : & \hspace{-2mm} g_1 \\ 
            \phi_1 \wedge \psi_2 \wedge f_1 > g_2    : & \hspace{-2mm} f_1 \\ 
            \phi_1 \wedge \psi_2 \wedge f_1 \leq g_2 : & \hspace{-2mm} g_2 \\ 
            \vdots & \vdots
            \end{cases}$
        \end{tabular}
    \end{center}
}%

$\casemax$ preserves the linearity of the constraints and the constant or linear nature of the $f_i$ and $g_i$. If the $f_i$ or$g_i$ are quadratic then the expressions $f_i > g_i$ or $f_i \leq g_i$ will be at most univariate quadratic and any such constraint can be linearised into a combination of at most two linear inequalities by completing the square. 

A case statement can be maximised with respect to a continuous parameter $y$ as {\small $ f_1(\vec{x}, y) = \contmax_{y}f_2(\vec{x}, y) $}. The continuous maximisation operation is a complex case operation whose explanation is beyond the scope of this paper. We refer the reader to~\parencite{Zamani_AAAI_2012} for further details.

In principle, case statements can be used to represent all MDP components. In practice, case statements are implemented using a more compact representation known as Extended Algebraic Decision Diagrams (XADDs) \parencite{Sanner_UAI_2011}, which also support efficient versions of all of the aforementioned operations.

\subsection{SDP for Parameterized Hybrid MDPs}

To calculate the exact solution to parameterized MDPs we begin by replacing all functions and operations in Equations~\eqref{eq:vi_qfunc} and~\eqref{eq:vi_vfunc} by their case statement equivalents. That is, we exchange operations such as $+$, $\times$ and $\mathnormal{max}$, by their symbolic equivalents, $\oplus$, $\otimes$ and $\casemax$, respectively, and express {\small $R(\vec{d}, \vec{x}, a)$},  {\small $T(\vec{d}, \vec{x}, a, \vec{d}' \vec{x}')$}, {\small $V^0(\vec{x})$} as case statements. The optimal solution to parameterized MDPs can now be described by the following recursive SDP equations:
%{\footnotesize 
%    \abovedisplayskip=0pt
%    \belowdisplayskip=0pt
%    \begin{align}
%        Q^{h}(\vec{x}, a; \theta) &= \Reward(\vec{x}, a; \theta) \, \oplus \nonumber \\
%        & \gamma \times \int \Transition(\vec{x}, a, \vec{x}'; \theta) \otimes V^{h-1}(\vec{x}'; \theta) d\vec{x}'\label{eq:qfunc}\\
%        V^{h}(\vec{x}; \theta) &= \casemax_{a \in A} \left\{ Q^{h}(\vec{x}, a; \theta) \right\} \label{eq:vfunc}
%    \end{align}
%}%

{\footnotesize 
    \abovedisplayskip=0pt
    \belowdisplayskip=0pt
    \begin{align}
        Q^{h}(\vec{d}, \vec{x}, a; \theta) &= R(\vec{d}, \vec{x}, a; \theta) \oplus \gamma \cdot  \nonumber \\ 
        & \sum_{\vec{d}'} \int_{\vec{x}'} \left( Equation~\eqref{eq:hmdp_tfunc} \right) \otimes V^{h-1}(\vec{d}, \vec{x}'; \theta) d\vec{x}' \label{eq:vi_qfunc} \\
        V^{h}(\vec{d}, \vec{x}; \theta) &= \casemax_{a \in A} \left\{ Q^{h}(\vec{d}, \vec{x}, a; \theta) \right\} \label{eq:vi_vfunc}
    \end{align}
}%

It can be proved that all of the SDP operations used in Algorithm 1 are closed form for LPWC or LPWL functions~\parencite{Sanner_UAI_2011,Zamani_AAAI_2012}.

In the next section we demonstrate how SDP can be used to compute exact solutions to a variety of parameterized hybrid MDPs.
